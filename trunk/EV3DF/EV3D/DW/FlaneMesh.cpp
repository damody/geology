//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : FlaneMesh.cpp
//  @ Date : 2010/4/10
//  @ Author : 
//
//


#include "FlaneMesh.h"

void FlaneMesh::SetSize(int iw, int ih) 
{
	m_w = iw;
	m_h = ih;
}

void FlaneMesh::SetColorTable(ColorTable* ct) 
{
	m_pCt = ct;
}

ColorTable* FlaneMesh::GetColorTablbe()
{
	return m_pCt;
}

void FlaneMesh::DrawFace() {
	assert(m_pCt);
	assert(m_pVertexData.size() != 0);
	assert(m_psIndices.size() != 0);
	if (!m_pCt) return;
	if (m_pVertexData.size() == 0) return;
	if (m_psIndices.size() == 0) return;
	switch(m_DrawType)
	{
	case USE_VERTEX:
		glEnableClientState(GL_VERTEX_ARRAY);
		glEnableClientState(GL_COLOR_ARRAY);
		glDisableClientState(GL_NORMAL_ARRAY);
		// `設定GPU要去哪讀取頂點座標資料`
		glVertexPointer(3, GL_FLOAT, sizeof(float)*3, &m_pVertexData[0]);
		// `設定GPU要去哪讀取頂點顏色資料`
		glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(Color4), &m_pColor[0]);
		// `畫出地板`
		glDrawElements (GL_TRIANGLE_STRIP, m_num_indices, GL_UNSIGNED_INT, &m_psIndices[0]);
		break;
	case USE_TEXTURE:
		break;
	}
}

void FlaneMesh::SetDrawMethod(int enumx) 
{
	m_DrawType = enumx;
}

// `產生x_grids * y_grids個格子的棋盤格模型`
bool FlaneMesh::GenerateGrids(int x_grids, int y_grids, Vector4& source, Vector4& w_length, Vector4& h_length)
{
	static int last_num_vertices = INT_MAX;
	static int last_num_indices = INT_MAX;
	Vector4 w_step = w_length / float(x_grids);
	Vector4 h_step = h_length / float(y_grids);
	m_p[0] = source;
	m_p[1] = 
		source + w_length;
	m_p[2] = 
		source + h_length;
	m_p[3] = 
		source + w_length + h_length;
	if (USE_TEXTURE == m_DrawType) return true;
	const int triangles_per_row = x_grids * 2;
	const int indices_per_row = triangles_per_row + 2;

	m_num_vertices = (x_grids + 1) * (y_grids + 1);
	m_pVertexData.resize(m_num_vertices*3);
	last_num_vertices = m_num_vertices;
	

	m_num_indices = indices_per_row * y_grids;
	m_psIndices.resize(m_num_indices);
	last_num_indices = m_num_indices;
	//` 使用triangle strip時, 三角形數目永遠等於索引值數目減去2`
	m_num_triangles = m_num_indices-2;
	Vector4 tmp = source;

	int x,y;
	int vertex_index = 0;
	for ( y=0; y<=y_grids; y++)
	{
		for ( x=0; x<=x_grids; x++, vertex_index++)
		{
			memcpy( &m_pVertexData[vertex_index*3], &tmp, sizeof(float)*3);
			tmp += w_step;
		}
		tmp -= float(x_grids+1)*w_step;
		tmp += h_step;
	}
	const int vertices_per_row = x_grids + 1;
	bool from_left_to_right = true;
	int  index_index = 0;

	for ( y=0; y<y_grids; y++ )
	{
		if ( from_left_to_right )
		{
			// `在奇數列的時候, 三角形從左排到右.`
			m_psIndices[index_index++] = unsigned int(y * vertices_per_row);
			m_psIndices[index_index++] = unsigned int(y * vertices_per_row + vertices_per_row);

			for ( x=0; x<x_grids; x++ )
			{
				vertex_index = y * vertices_per_row + x;
				m_psIndices[index_index++] = unsigned int(vertex_index + 1);
				m_psIndices[index_index++] = unsigned int(vertex_index + 1 + vertices_per_row);
			}
		}
		else
		{
			// `在偶數列的時候, 三角形從右排到左.`
			m_psIndices[index_index++] = unsigned int(y * vertices_per_row + x_grids);
			m_psIndices[index_index++] = unsigned int((y+1) * vertices_per_row + x_grids);

			for ( x=x_grids; x>0; x-- )
			{
				vertex_index = y * vertices_per_row + x;
				m_psIndices[index_index++] = unsigned int(vertex_index - 1);
				m_psIndices[index_index++] = unsigned int(vertex_index - 1 + vertices_per_row);
			}
		}
		from_left_to_right = !from_left_to_right;
	}
	m_pColor.resize(m_num_vertices*4);
	return true;
}

bool FlaneMesh::DataToColor( ColorTable* pct, double* pd, Color4* pc4, int num )
{
	for (int i=0;i<num;i++)
	{
		pc4[i] = pct->GetColor4(float(pd[i]));
	}
	return true;
}

bool FlaneMesh::ConvertGetData( double* pd, int num )
{
	if (num == 0) num = m_num_vertices;
	assert(m_pCt);
	assert(m_pColor.size() != 0);
	assert(m_w*m_h>0);
	if (!m_pCt) return false;
	if (m_pColor.size() == 0) return false;
	if (m_w*m_h<0) return false;
	DataToColor(m_pCt, pd, (Color4*)&m_pColor[0], num);
	return true;
}

FlaneMesh::~FlaneMesh()
{
}